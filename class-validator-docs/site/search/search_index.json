{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Class Validator","text":"<p>Class-validator is a powerful validation library for TypeScript and JavaScript that allows you to use decorator and non-decorator based validation. It uses validator.js internally to perform validation and works on both browser and node.js platforms.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Decorator and non-decorator based validation</li> <li>Cross-platform compatibility (browser &amp; node.js)</li> <li>Works with TypeScript and JavaScript</li> <li>Validates objects against classes</li> <li>Validates arrays and nested objects</li> <li>Custom validation decorators</li> <li>Service container support</li> <li>Rich set of built-in validators</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import { validate } from 'class-validator';\nimport { Length, Contains, IsInt, Min, Max, IsEmail } from 'class-validator';\n\nexport class Post {\n    @Length(10, 20)\n    title: string;\n\n    @Contains('hello')\n    text: string;\n\n    @IsInt()\n    @Min(0)\n    @Max(10)\n    rating: number;\n\n    @IsEmail()\n    email: string;\n}\n\nlet post = new Post();\npost.title = 'Hello'; // too short\npost.text = 'this is a great post about hell world'; // doesn't contain \"hello\"\npost.rating = 11; // too high\npost.email = 'google.com'; // not an email\n\nvalidate(post).then(errors =&gt; {\n    if (errors.length &gt; 0) {\n        console.log('validation failed. errors: ', errors);\n    } else {\n        console.log('validation succeed');\n    }\n});\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>For information about how to contribute to this project, see TypeStack's general contribution guide.</p>"},{"location":"arrays/","title":"Validating Arrays","text":""},{"location":"arrays/#basic-array-validation","title":"Basic Array Validation","text":"<p>If your field is an array and you want to perform validation of each item in the array, you must specify a special <code>each: true</code> decorator option:</p> <pre><code>import { MaxLength } from 'class-validator';\n\nexport class Post {\n    @MaxLength(20, {\n        each: true,\n    })\n    tags: string[];\n}\n</code></pre>"},{"location":"arrays/#array-specific-decorators","title":"Array-specific Decorators","text":"<p>There are also several decorators specifically for array validation:</p> Decorator Description <code>@ArrayContains(values: any[])</code> Checks if array contains all values from the given array of values. <code>@ArrayNotContains(values: any[])</code> Checks if array does not contain any of the given values. <code>@ArrayNotEmpty()</code> Checks if given array is not empty. <code>@ArrayMinSize(min: number)</code> Checks if array's length is greater than or equal to the specified number. <code>@ArrayMaxSize(max: number)</code> Checks if array's length is less or equal to the specified number. <code>@ArrayUnique()</code> Checks if all array's values are unique. <p>Example:</p> <pre><code>import { ArrayMinSize, ArrayMaxSize, ArrayUnique } from 'class-validator';\n\nexport class Post {\n    @ArrayMinSize(1)\n    @ArrayMaxSize(10)\n    @ArrayUnique()\n    tags: string[];\n}\n</code></pre>"},{"location":"conditional/","title":"Conditional Validation","text":"<p>The conditional validation decorator (<code>@ValidateIf</code>) can be used to ignore the validators on a property when the provided condition function returns false.</p>"},{"location":"conditional/#basic-usage","title":"Basic Usage","text":"<pre><code>import { ValidateIf, IsNotEmpty } from 'class-validator';\n\nexport class Post {\n    otherProperty: string;\n\n    @ValidateIf(o =&gt; o.otherProperty === 'value')\n    @IsNotEmpty()\n    example: string;\n}\n</code></pre> <p>In this example, the validation rules applied to <code>example</code> won't be run unless the object's <code>otherProperty</code> is <code>\"value\"</code>.</p>"},{"location":"conditional/#important-notes","title":"Important Notes","text":"<ol> <li>When the condition is false, all validation decorators are ignored</li> <li>The condition function takes the object being validated as a parameter</li> <li>The condition function must return a boolean</li> <li>Multiple <code>@ValidateIf</code> decorators can be used on the same property</li> </ol>"},{"location":"conditional/#advanced-example","title":"Advanced Example","text":"<pre><code>import { ValidateIf, IsNotEmpty, IsString } from 'class-validator';\n\nexport class User {\n    @IsString()\n    type: string;\n\n    @ValidateIf(o =&gt; o.type === 'admin')\n    @IsNotEmpty()\n    adminKey: string;\n\n    @ValidateIf(o =&gt; o.type === 'user')\n    @IsNotEmpty()\n    userKey: string;\n}\n</code></pre>"},{"location":"context/","title":"Passing Context to Decorators","text":""},{"location":"context/#overview","title":"Overview","text":"<p>It's possible to pass a custom object to decorators which will be accessible on the <code>ValidationError</code> instance of the property if validation failed.</p>"},{"location":"context/#example","title":"Example","text":"<pre><code>import { validate } from 'class-validator';\n\nclass MyClass {\n    @MinLength(32, {\n        message: 'EIC code must be at least 32 characters',\n        context: {\n            errorCode: 1003,\n            developerNote: 'The validated string must contain 32 or more characters.',\n        },\n    })\n    eicCode: string;\n}\n\nconst model = new MyClass();\n\nvalidate(model).then(errors =&gt; {\n    // errors[0].contexts['minLength'].errorCode === 1003\n});\n</code></pre>"},{"location":"context/#use-cases","title":"Use Cases","text":"<ol> <li>Adding error codes for API responses</li> <li>Including developer notes in validation errors</li> <li>Providing additional metadata for error handling</li> <li>Customizing error messages based on context</li> </ol>"},{"location":"custom-validation/","title":"Custom Validation","text":""},{"location":"custom-validation/#custom-validation-classes","title":"Custom Validation Classes","text":""},{"location":"custom-validation/#creating-a-custom-validator","title":"Creating a Custom Validator","text":"<pre><code>import { ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments } from 'class-validator';\n\n@ValidatorConstraint({ name: 'customText', async: false })\nexport class CustomTextLength implements ValidatorConstraintInterface {\n    validate(text: string, args: ValidationArguments) {\n        return text.length &gt; 1 &amp;&amp; text.length &lt; 10; \n    }\n\n    defaultMessage(args: ValidationArguments) {\n        return 'Text ($value) is too short or too long!';\n    }\n}\n</code></pre>"},{"location":"custom-validation/#using-custom-validator","title":"Using Custom Validator","text":"<pre><code>import { Validate } from 'class-validator';\nimport { CustomTextLength } from './CustomTextLength';\n\nexport class Post {\n    @Validate(CustomTextLength, {\n        message: 'Title is too short or long!'\n    })\n    title: string;\n}\n</code></pre>"},{"location":"custom-validation/#custom-validation-decorators","title":"Custom Validation Decorators","text":""},{"location":"custom-validation/#creating-a-custom-decorator","title":"Creating a Custom Decorator","text":"<pre><code>import { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator';\n\nexport function IsLongerThan(property: string, validationOptions?: ValidationOptions) {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: 'isLongerThan',\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [property],\n            options: validationOptions,\n            validator: {\n                validate(value: any, args: ValidationArguments) {\n                    const [relatedPropertyName] = args.constraints;\n                    const relatedValue = (args.object as any)[relatedPropertyName];\n                    return typeof value === 'string' &amp;&amp; \n                           typeof relatedValue === 'string' &amp;&amp; \n                           value.length &gt; relatedValue.length;\n                }\n            }\n        });\n    };\n}\n</code></pre>"},{"location":"custom-validation/#using-custom-decorator","title":"Using Custom Decorator","text":"<pre><code>import { IsLongerThan } from './IsLongerThan';\n\nexport class Post {\n    title: string;\n\n    @IsLongerThan('title', {\n        message: 'Text must be longer than the title'\n    })\n    text: string;\n}\n</code></pre>"},{"location":"decorators/","title":"Validation Decorators","text":""},{"location":"decorators/#common-validation-decorators","title":"Common validation decorators","text":"Decorator Description <code>@IsDefined(value: any)</code> Checks if value is defined (!== undefined, !== null). This is the only decorator that ignores skipMissingProperties option. <code>@IsOptional()</code> Checks if given value is empty (=== null, === undefined) and if so, ignores all the validators on the property. <code>@Equals(comparison: any)</code> Checks if value equals (\"===\") comparison. <code>@NotEquals(comparison: any)</code> Checks if value not equal (\"!==\") comparison. <code>@IsEmpty()</code> Checks if given value is empty (=== '', === null, === undefined). <code>@IsNotEmpty()</code> Checks if given value is not empty (!== '', !== null, !== undefined). <code>@IsIn(values: any[])</code> Checks if value is in an array of allowed values. <code>@IsNotIn(values: any[])</code> Checks if value is not in an array of disallowed values."},{"location":"decorators/#type-validation-decorators","title":"Type validation decorators","text":"Decorator Description <code>@IsBoolean()</code> Checks if a value is a boolean. <code>@IsDate()</code> Checks if the value is a date. <code>@IsString()</code> Checks if the value is a string. <code>@IsNumber(options: IsNumberOptions)</code> Checks if the value is a number. <code>@IsInt()</code> Checks if the value is an integer number. <code>@IsArray()</code> Checks if the value is an array <code>@IsEnum(entity: object)</code> Checks if the value is a valid enum <p>See the full list of validation decorators for more details.</p>"},{"location":"groups/","title":"Validation Groups","text":""},{"location":"groups/#overview","title":"Overview","text":"<p>In different situations you may want to use different validation schemas for the same object. In such cases you can use validation groups.</p>"},{"location":"groups/#basic-usage","title":"Basic Usage","text":"<pre><code>import { validate, Min, Length } from 'class-validator';\n\nexport class User {\n    @Min(12, {\n        groups: ['registration']\n    })\n    age: number;\n\n    @Length(2, 20, {\n        groups: ['registration', 'admin']\n    })\n    name: string;\n}\n\nlet user = new User();\nuser.age = 10;\nuser.name = 'Alex';\n\nvalidate(user, { \n    groups: ['registration'] \n}); // this will not pass validation\n\nvalidate(user, { \n    groups: ['admin'] \n}); // this will pass validation\n\nvalidate(user, { \n    groups: ['registration', 'admin'] \n}); // this will not pass validation\n\nvalidate(user, { \n    groups: undefined // the default\n}); // this will not pass validation\n</code></pre>"},{"location":"groups/#important-notes","title":"Important Notes","text":"<ol> <li>The <code>always: true</code> flag in validation options means the validation must be applied regardless of groups</li> <li>Multiple groups can be specified for a single decorator</li> <li>If no groups are specified, the default group is used</li> <li>Groups can be used to create different validation scenarios for the same object</li> </ol>"},{"location":"inheritance/","title":"Inheriting Validation Decorators","text":"<p>When you define a subclass that extends from another class, the subclass will automatically inherit the parent's decorators. If a property is redefined in the descendant class, decorators will be applied from both its own class and the base class.</p>"},{"location":"inheritance/#example","title":"Example","text":"<pre><code>import { validate } from 'class-validator';\n\nclass BaseContent {\n    @IsEmail()\n    email: string;\n\n    @IsString()\n    password: string;\n}\n\nclass User extends BaseContent {\n    @MinLength(10)\n    @MaxLength(20)\n    name: string;\n\n    @Contains('hello')\n    welcome: string;\n\n    @MinLength(20)\n    password: string;\n}\n\nlet user = new User();\n\nuser.email = 'invalid email'; // inherited property\nuser.password = 'too short'; // password will be validated against IsString and MinLength\nuser.name = 'not valid';\nuser.welcome = 'helo';\n\nvalidate(user).then(errors =&gt; {\n    // handle errors\n}); // it will return errors for email, password, name and welcome properties\n</code></pre>"},{"location":"inheritance/#inheritance-rules","title":"Inheritance Rules","text":"<ol> <li>All decorators from the base class are inherited</li> <li>Decorators can be overridden in the child class</li> <li>Multiple decorators are combined when a property is redefined</li> <li>Inheritance works with multiple levels of inheritance</li> </ol>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>npm version 6 or higher</li> <li>Node.js</li> </ul>"},{"location":"installation/#installing-the-package","title":"Installing the Package","text":"<pre><code>npm install class-validator --save\n</code></pre> <p>Note</p> <p>It's important to use at least npm@6 when using class-validator. From npm@6 the dependency tree is flattened, which is required by class-validator to function properly.</p>"},{"location":"installation/#basic-setup","title":"Basic Setup","text":"<ol> <li>Import the necessary decorators:</li> </ol> <pre><code>import { validate } from 'class-validator';\n</code></pre> <ol> <li>Enable decorators in your <code>tsconfig.json</code>:</li> </ol> <pre><code>{\n    \"compilerOptions\": {\n        \"experimentalDecorators\": true\n    }\n}\n</code></pre> <p>You're now ready to start using class-validator in your project!</p>"},{"location":"manual-validation/","title":"Manual Validation","text":""},{"location":"manual-validation/#overview","title":"Overview","text":"<p>There are several methods in the Validator that allow performing non-decorator based validation.</p>"},{"location":"manual-validation/#basic-usage","title":"Basic Usage","text":"<pre><code>import { isEmpty, isBoolean } from 'class-validator';\n\nisEmpty(value);\nisBoolean(value);\n</code></pre>"},{"location":"manual-validation/#available-validation-functions","title":"Available Validation Functions","text":"<p>All validation decorators have corresponding functions that can be used manually:</p> <pre><code>import { \n    isEmail,\n    isLength,\n    isInt,\n    min,\n    max \n} from 'class-validator';\n\n// String validation\nisEmail('example@email.com'); // true\nisLength('text', 2, 10); // true\n\n// Number validation\nisInt(123); // true\nmin(5, 3); // true\nmax(5, 10); // true\n</code></pre>"},{"location":"manual-validation/#synchronous-vs-asynchronous","title":"Synchronous vs Asynchronous","text":"<p>Most validation functions are synchronous, but some (like those involving database queries) are asynchronous:</p> <pre><code>import { validate, validateOrReject } from 'class-validator';\n\n// Synchronous\nconst errors = validateSync(object);\nif (errors.length &gt; 0) {\n    console.log('Validation failed:', errors);\n}\n\n// Asynchronous\nvalidate(object).then(errors =&gt; {\n    if (errors.length &gt; 0) {\n        console.log('Validation failed:', errors);\n    }\n});\n\n// Using validateOrReject\nvalidateOrReject(object).catch(errors =&gt; {\n    console.log('Validation failed:', errors);\n});\n</code></pre>"},{"location":"messages/","title":"Validation Messages","text":"<p>You can specify validation messages in the decorator options and that message will be returned in the <code>ValidationError</code> returned by the <code>validate</code> method (in the case that validation for this field fails).</p>"},{"location":"messages/#basic-usage","title":"Basic Usage","text":"<pre><code>import { MinLength, MaxLength } from 'class-validator';\n\nexport class Post {\n    @MinLength(10, {\n        message: 'Title is too short',\n    })\n    @MaxLength(50, {\n        message: 'Title is too long',\n    })\n    title: string;\n}\n</code></pre>"},{"location":"messages/#message-variables","title":"Message Variables","text":"<p>There are few special tokens you can use in your messages:</p> <ul> <li><code>$value</code> - the value that is being validated</li> <li><code>$property</code> - name of the object's property being validated</li> <li><code>$target</code> - name of the object's class being validated</li> <li><code>$constraint1</code>, <code>$constraint2</code>, ... <code>$constraintN</code> - constraints defined by specific validation type</li> </ul> <p>Example:</p> <pre><code>import { MinLength, MaxLength } from 'class-validator';\n\nexport class Post {\n    @MinLength(10, {\n        message: 'Title is too short. Minimal length is $constraint1 characters, but actual is $value',\n    })\n    @MaxLength(50, {\n        message: 'Title is too long. Maximal length is $constraint1 characters, but actual is $value',\n    })\n    title: string;\n}\n</code></pre>"},{"location":"messages/#dynamic-messages","title":"Dynamic Messages","text":"<p>You can also provide a function that returns a message:</p> <pre><code>import { MinLength, ValidationArguments } from 'class-validator';\n\nexport class Post {\n    @MinLength(10, {\n        message: (args: ValidationArguments) =&gt; {\n            if (args.value.length === 1) {\n                return 'Too short, minimum length is 1 character';\n            } else {\n                return 'Too short, minimum length is ' + args.constraints[0] + ' characters';\n            }\n        },\n    })\n    title: string;\n}\n</code></pre>"},{"location":"nested-objects/","title":"Validating Nested Objects","text":""},{"location":"nested-objects/#basic-nested-validation","title":"Basic Nested Validation","text":"<p>If your object contains nested objects and you want the validator to perform their validation too, then you need to use the <code>@ValidateNested()</code> decorator:</p> <pre><code>import { ValidateNested } from 'class-validator';\n\nexport class Post {\n    @ValidateNested()\n    user: User;\n}\n</code></pre>"},{"location":"nested-objects/#array-of-nested-objects","title":"Array of Nested Objects","text":"<p>It also works with arrays of nested objects:</p> <pre><code>import { ValidateNested } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class Post {\n    @ValidateNested({ each: true })\n    @Type(() =&gt; User)\n    users: User[];\n}\n</code></pre>"},{"location":"nested-objects/#deep-nested-objects","title":"Deep Nested Objects","text":"<p>You can validate deeply nested objects:</p> <pre><code>import { ValidateNested } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class Profile {\n    @IsString()\n    name: string;\n}\n\nexport class User {\n    @ValidateNested()\n    @Type(() =&gt; Profile)\n    profile: Profile;\n}\n\nexport class Post {\n    @ValidateNested()\n    @Type(() =&gt; User)\n    user: User;\n}\n</code></pre> <p>Note: The nested object must be an instance of a class, otherwise <code>@ValidateNested</code> won't know what to validate against.</p>"},{"location":"promises/","title":"Validating Promises","text":""},{"location":"promises/#basic-promise-validation","title":"Basic Promise Validation","text":"<p>If your object contains properties with Promise-returned values that should be validated, you need to use the <code>@ValidatePromise()</code> decorator:</p> <pre><code>import { ValidatePromise, Min } from 'class-validator';\n\nexport class Post {\n    @Min(0)\n    @ValidatePromise()\n    userId: Promise&lt;number&gt;;\n}\n</code></pre>"},{"location":"promises/#combining-with-nested-validation","title":"Combining with Nested Validation","text":"<p>It works great with <code>@ValidateNested</code> decorator:</p> <pre><code>import { ValidateNested, ValidatePromise } from 'class-validator';\n\nexport class Post {\n    @ValidateNested()\n    @ValidatePromise()\n    user: Promise&lt;User&gt;;\n}\n</code></pre>"},{"location":"promises/#async-validation","title":"Async Validation","text":"<p>When validating promises, the validation itself becomes asynchronous:</p> <pre><code>import { validate } from 'class-validator';\n\nlet post = new Post();\npost.userId = Promise.resolve(1);\n\nvalidate(post).then(errors =&gt; {\n    // handle errors\n});\n</code></pre>"},{"location":"service-container/","title":"Using Service Container","text":""},{"location":"service-container/#overview","title":"Overview","text":"<p>Validator supports service container integration when you want to inject dependencies into your custom validator constraint classes.</p>"},{"location":"service-container/#integration-with-typedi","title":"Integration with TypeDI","text":"<pre><code>import { Container } from 'typedi';\nimport { useContainer, Validator } from 'class-validator';\n\n// do this somewhere in the global application level:\nuseContainer(Container);\nlet validator = Container.get(Validator);\n\n// now everywhere you can inject Validator class which will go from the container\n// also you can inject classes using constructor injection into your custom ValidatorConstraint-s\n</code></pre>"},{"location":"service-container/#example-with-dependencies","title":"Example with Dependencies","text":"<pre><code>import { ValidatorConstraint, ValidatorConstraintInterface } from 'class-validator';\nimport { UserRepository } from './UserRepository';\n\n@ValidatorConstraint({ async: true })\nexport class IsUserAlreadyExistConstraint implements ValidatorConstraintInterface {\n    constructor(protected userRepository: UserRepository) {}\n\n    validate(userName: string) {\n        return this.userRepository.findOneByName(userName).then(user =&gt; {\n            if (user) return false;\n            return true;\n        });\n    }\n}\n</code></pre>"},{"location":"usage/","title":"Basic Usage","text":""},{"location":"usage/#creating-a-validated-class","title":"Creating a Validated Class","text":"<p>To start using class-validator, first create a class with validation decorators:</p> <pre><code>import { Length, IsEmail, Min } from 'class-validator';\n\nexport class User {\n    @Length(4, 20)\n    username: string;\n\n    @IsEmail()\n    email: string;\n\n    @Min(18)\n    age: number;\n}\n</code></pre>"},{"location":"usage/#validating-an-object","title":"Validating an Object","text":"<p>Once you have a class with validation decorators, you can validate instances of this class:</p> <pre><code>import { validate } from 'class-validator';\n\nlet user = new User();\nuser.username = \"Sh\"; // too short\nuser.email = \"invalid-email\"; // not an email\nuser.age = 16; // under 18\n\nvalidate(user).then(errors =&gt; {\n    if (errors.length &gt; 0) {\n        console.log('Validation failed:', errors);\n    } else {\n        console.log('Validation successful');\n    }\n});\n</code></pre>"},{"location":"usage/#validation-options","title":"Validation Options","text":"<p>You can pass options to the validate function:</p> <pre><code>validate(user, {\n    skipMissingProperties: true, // skip validation of missing properties\n    whitelist: true, // strip non-decorated properties\n    forbidNonWhitelisted: true // throw error if non-whitelisted properties exist\n});\n</code></pre>"},{"location":"usage/#synchronous-validation","title":"Synchronous Validation","text":"<p>If you don't need async validation, you can use <code>validateSync</code>:</p> <pre><code>import { validateSync } from 'class-validator';\n\nconst errors = validateSync(user);\nif (errors.length &gt; 0) {\n    console.log('Validation failed:', errors);\n} else {\n    console.log('Validation successful');\n}\n</code></pre>"},{"location":"validation-decorators/","title":"Validation Decorators Reference","text":""},{"location":"validation-decorators/#common-validation-decorators","title":"Common Validation Decorators","text":"Decorator Description <code>@IsDefined(value: any)</code> Checks if value is defined (!== undefined, !== null). <code>@IsOptional()</code> Ignores all validators if value is empty. <code>@Equals(comparison: any)</code> Checks if value equals comparison. <code>@NotEquals(comparison: any)</code> Checks if value not equals comparison. <code>@IsEmpty()</code> Checks if given value is empty. <code>@IsNotEmpty()</code> Checks if given value is not empty. <code>@IsIn(values: any[])</code> Checks if value is in a array of allowed values. <code>@IsNotIn(values: any[])</code> Checks if value is not in a array of disallowed values."},{"location":"validation-decorators/#string-validation-decorators","title":"String Validation Decorators","text":"Decorator Description <code>@IsString()</code> Checks if the string is a string. <code>@Length(min: number, max?: number)</code> Checks if the string's length falls in range. <code>@MinLength(min: number)</code> Checks if the string's length is not less than given number. <code>@MaxLength(max: number)</code> Checks if the string's length is not more than given number. <code>@Matches(pattern: RegExp)</code> Checks if string matches the pattern. <code>@IsEmail()</code> Checks if the string is an email. <code>@IsURL()</code> Checks if the string is an URL. <code>@IsFQDN()</code> Checks if the string is a fully qualified domain name."},{"location":"validation-decorators/#number-validation-decorators","title":"Number Validation Decorators","text":"Decorator Description <code>@IsNumber()</code> Checks if the value is a number. <code>@IsInt()</code> Checks if the value is an integer. <code>@Min(min: number)</code> Checks if the value is greater than or equal to given number. <code>@Max(max: number)</code> Checks if the value is less than or equal to given number. <code>@IsPositive()</code> Checks if the value is a positive number. <code>@IsNegative()</code> Checks if the value is a negative number."},{"location":"validation-decorators/#date-validation-decorators","title":"Date Validation Decorators","text":"Decorator Description <code>@IsDate()</code> Checks if the value is a Date. <code>@MinDate(date: Date)</code> Checks if the date is greater than given date. <code>@MaxDate(date: Date)</code> Checks if the date is less than given date."},{"location":"validation-decorators/#array-validation-decorators","title":"Array Validation Decorators","text":"Decorator Description <code>@IsArray()</code> Checks if the value is an array <code>@ArrayContains(values: any[])</code> Checks if array contains all values from the given array <code>@ArrayNotContains(values: any[])</code> Checks if array does not contain any of the given values <code>@ArrayNotEmpty()</code> Checks if given array is not empty <code>@ArrayMinSize(min: number)</code> Checks if array's length is greater than or equal to specified number <code>@ArrayMaxSize(max: number)</code> Checks if array's length is less or equal to specified number <code>@ArrayUnique()</code> Checks if all array's values are unique"},{"location":"whitelisting/","title":"Whitelisting","text":""},{"location":"whitelisting/#overview","title":"Overview","text":"<p>Even if your object is an instance of a validation class, it can contain additional properties that are not defined. If you don't want to have such properties on your object, you can use whitelisting.</p>"},{"location":"whitelisting/#basic-usage","title":"Basic Usage","text":"<pre><code>import { validate } from 'class-validator';\n\n// ... class definition\n\nvalidate(post, { whitelist: true });\n</code></pre> <p>This will strip all properties that don't have any decorators. If no other decorator is suitable for your property, you can use <code>@Allow</code> decorator:</p> <pre><code>import { validate, Allow, Min } from 'class-validator';\n\nexport class Post {\n    @Allow()\n    title: string;\n\n    @Min(0)\n    views: number;\n\n    nonWhitelistedProperty: number;\n}\n\nlet post = new Post();\npost.title = 'Hello world!';\npost.views = 420;\n\npost.nonWhitelistedProperty = 69;\n(post as any).anotherNonWhitelistedProperty = \"something\";\n\nvalidate(post, { whitelist: true }).then(errors =&gt; {\n    // post.nonWhitelistedProperty is not defined\n    // (post as any).anotherNonWhitelistedProperty is not defined\n});\n</code></pre>"},{"location":"whitelisting/#forbidding-non-whitelisted-properties","title":"Forbidding Non-whitelisted Properties","text":"<p>If you would rather have an error thrown when any non-whitelisted properties are present:</p> <pre><code>import { validate } from 'class-validator';\n\nvalidate(post, { \n    whitelist: true, \n    forbidNonWhitelisted: true \n});\n</code></pre>"}]}